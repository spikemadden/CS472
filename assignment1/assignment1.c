#include <stdio.h>#include <string.h>#include <limits.h>#include "cachetable.h"#define cpuid(a, b, c, d) __asm__( "cpuid" : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx) : "a"(a), "b"(b), "c"(c), "d"(d))#define b(val, base, end) ((val << (__WORDSIZE-end-1)) >> (__WORDSIZE-end+base-1))int main(int argc, char **argv){        unsigned long eax, ebx, ecx, edx;        char brand[48];        // l1 cache size        cpuid(0x04, 0, 0, 0);        printf("l1 cache size: %ld bytes\n", (b(ebx, 22, 31) + 1) * (b(ebx, 12, 21) + 1) * (b(ebx, 0, 11) + 1) * (b(ecx, 0, 31) + 1));        printf("l1 line size: %ld bytes\n", b(ebx, 0, 11));        // l1 instruction cache size        cpuid(0x04, 0, 0x01, 0);        printf("l1 instruction cache size: %ld bytes\n", (b(ebx, 22, 31) + 1) * (b(ebx, 12, 21) + 1) * (b(ebx, 0, 11) + 1) * (b(ecx, 0, 31) + 1));        printf("l1 instruction cache line size: %ld bytes\n", b(ebx, 0, 11));        // l2 cache size        cpuid(0x04, 0, 0x02, 0);        printf("l2 instruction cache size: %ld bytes\n", (b(ebx, 22, 31) + 1) * (b(ebx, 12, 21) + 1) * (b(ebx, 0, 11) + 1) * (b(ecx, 0, 31) + 1));        // l3 cache size        cpuid(0x04, 0, 0x03, 0);        printf("l3 instruction cache size: %ld bytes\n", (b(ebx, 22, 31) + 1) * (b(ebx, 12, 21) + 1) * (b(ebx, 0, 11) + 1) * (b(ecx, 0, 31) + 1));        printf("\n");        cpuid(0x02, 0, 0, 0);        printf("TLB cache information from lookup table.\n");        for (int i = 0; i < 109; i++) {            if (b(eax, 0, 7) == 1) {                if (b(eax, 8, 15) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(eax, 16, 23) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(eax, 23, 32) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }            }            if (b(ebx, 28, 31) == 0) {                if (b(ebx, 0, 7) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(ebx, 8, 15) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(eax, 16, 23) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(eax, 23, 32) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }            }            if (b(ecx, 28, 31) == 0) {                if (b(ecx, 0, 7) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(ecx, 8, 15) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(ecx, 16, 23) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(ecx, 23, 32) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }            }            if (b(edx, 28, 31) == 0) {                if (b(edx, 0, 7) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(edx, 8, 15) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(edx, 16, 23) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }                else if (b(edx, 23, 32) == CacheTable[i].hexvalue) {                    printf("%s\n", CacheTable[i].description);                }            }        }        printf("\n");        // physical and logical address width        cpuid(0x80000008, 0, 0, 0);        printf("physical address width: %ld bytes\n", b(eax, 0, 7));        printf("linear address width: %ld bytes\n", b(eax, 8, 15));        printf("\n");        cpuid(0x0B, 0, 0, 0);        printf("number of logical processors: %d", b(ebx, 0, 15));        printf("\n");        // cpu family and model        cpuid(0x01, 0, 0, 0);        printf("processor family: %ld\n", b(eax, 8, 11));        printf("model number: %ld\n", (b(eax, 16, 19) << 4) + b(eax, 4, 7));        // cpu brand        cpuid(0x80000002, 0, 0, 0);        memcpy(brand, (char*)&eax, 4);        memcpy(brand + 4, (char*)&ebx, 4);        memcpy(brand + 8, (char*)&ecx, 4);      	memcpy(brand + 12, (char*)&edx, 4);        cpuid(0x80000003, 0, 0, 0);        memcpy(brand + 16, (char*)&eax, 4);        memcpy(brand + 20, (char*)&ebx, 4);        memcpy(brand + 24, (char*)&ecx, 4);      	memcpy(brand + 28, (char*)&edx, 4);        cpuid(0x80000004, 0, 0, 0);        memcpy(brand + 32, (char*)&eax, 4);        memcpy(brand + 36, (char*)&ebx, 4);        memcpy(brand + 40, (char*)&ecx, 4);      	memcpy(brand + 44, (char*)&edx, 4);        printf("processor brand: %s\n", brand);        // processor frequencies        cpuid(0x16, 0, 0, 0);        printf("processor base frequency (MHz): %ld\n", b(eax, 0, 15));        printf("processor max frequency (MHz): %ld\n", b(ebx, 0, 15));        printf("\n");        // cpu features available        cpuid(0x80000001, 0, 0, 0);        printf("available cpu features\n");        printf("LAHF/SAHF available in 64 bit mode: %d\n", b(ecx, 0, 0));        printf("LZCNT: %d\n", b(ecx, 5, 5));        printf("PREFETCHW: %d\n", b(ecx, 8, 8));        printf("SYSCALL/SYSRET available in 64 bit mode: %d\n", b(edx, 11,11));        printf("Execute Disable Bit available: %d\n", b(edx, 20, 20));        printf("1 GByte pages available: %d\n", b(edx, 26, 26));        printf("RDTSCP and IA32_TSC_AUX are available: %d\n", b(edx, 27, 27));        printf("Intel 64 architecture available: %d\n", b(edx, 29, 29));        return(0);}